name: Deploy Web App

on:
  workflow_run:
    workflows: ["Container Build and Push - Web App"]
    types:
      - completed
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  SERVICE_NAME: web-app

permissions:
  contents: read
  packages: read
  deployments: write
  id-token: write

jobs:
  determine-deployment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      version: ${{ steps.version.outputs.version }}
      should-deploy: ${{ steps.check.outputs.should-deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENVIRONMENT="development"
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            ENVIRONMENT="development"
          else
            ENVIRONMENT="review"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "Determined environment: $ENVIRONMENT"

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="$(date +%Y%m%d)-${GITHUB_SHA::8}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version to deploy: $VERSION"

      - name: Check if should deploy
        id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.workflow_run.conclusion }}" = "success" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

  deploy-development:
    needs: determine-deployment
    if: needs.determine-deployment.outputs.should-deploy == 'true' && needs.determine-deployment.outputs.environment == 'development'
    runs-on: ubuntu-latest
    environment: 
      name: development
      url: https://web-app-dev.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_DEV }}
          aws-region: us-east-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-east-1 --name dev-cluster

      - name: Create namespace if not exists
        run: |
          kubectl create namespace web-app-dev --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to development
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.version }}"
          
          # Create deployment manifest
          cat << EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: web-app-dev
            labels:
              app: ${{ env.SERVICE_NAME }}
              environment: development
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: ${{ env.SERVICE_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.SERVICE_NAME }}
                  version: ${{ needs.determine-deployment.outputs.version }}
              spec:
                containers:
                - name: ${{ env.SERVICE_NAME }}
                  image: $IMAGE
                  ports:
                  - containerPort: 3000
                  env:
                  - name: NODE_ENV
                    value: "development"
                  - name: PORT
                    value: "3000"
                  resources:
                    requests:
                      memory: "64Mi"
                      cpu: "50m"
                    limits:
                      memory: "128Mi"
                      cpu: "100m"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 5
                    periodSeconds: 5
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: web-app-dev
          spec:
            selector:
              app: ${{ env.SERVICE_NAME }}
            ports:
            - port: 80
              targetPort: 3000
            type: LoadBalancer
          EOF

      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} -n web-app-dev --timeout=300s

      - name: Run smoke tests
        run: |
          # Get service endpoint
          SERVICE_IP=$(kubectl get service ${{ env.SERVICE_NAME }} -n web-app-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "localhost")
          
          # Wait for service to be ready
          timeout 60 bash -c "until curl -f http://$SERVICE_IP/health 2>/dev/null; do sleep 5; done" || echo "Health check timeout"
          
          # Run smoke tests
          echo "Running smoke tests for web-app"
          curl -f "http://$SERVICE_IP/health" || exit 1
          curl -f "http://$SERVICE_IP/" || exit 1

  deploy-staging:
    needs: [determine-deployment, deploy-development]
    if: needs.determine-deployment.outputs.should-deploy == 'true' && (needs.determine-deployment.outputs.environment == 'staging' || (needs.determine-deployment.outputs.environment == 'development' && github.ref == 'refs/heads/main'))
    runs-on: ubuntu-latest
    environment: 
      name: staging
      url: https://web-app-staging.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_STAGING }}
          aws-region: us-east-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-east-1 --name staging-cluster

      - name: Create namespace if not exists
        run: |
          kubectl create namespace web-app-staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to staging
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.version }}"
          
          # Create staging deployment with higher resources
          cat << EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: web-app-staging
            labels:
              app: ${{ env.SERVICE_NAME }}
              environment: staging
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.SERVICE_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.SERVICE_NAME }}
                  version: ${{ needs.determine-deployment.outputs.version }}
              spec:
                containers:
                - name: ${{ env.SERVICE_NAME }}
                  image: $IMAGE
                  ports:
                  - containerPort: 3000
                  env:
                  - name: NODE_ENV
                    value: "staging"
                  - name: PORT
                    value: "3000"
                  resources:
                    requests:
                      memory: "128Mi"
                      cpu: "100m"
                    limits:
                      memory: "256Mi"
                      cpu: "200m"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 5
                    periodSeconds: 5
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: web-app-staging
          spec:
            selector:
              app: ${{ env.SERVICE_NAME }}
            ports:
            - port: 80
              targetPort: 3000
            type: LoadBalancer
          ---
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: web-app-staging
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-prod
          spec:
            tls:
            - hosts:
              - web-app-staging.example.com
              secretName: web-app-staging-tls
            rules:
            - host: web-app-staging.example.com
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: ${{ env.SERVICE_NAME }}
                      port:
                        number: 80
          EOF

      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} -n web-app-staging --timeout=600s

      - name: Run integration tests
        run: |
          # Wait for ingress to be ready
          timeout 120 bash -c "until curl -f https://web-app-staging.example.com/health 2>/dev/null; do sleep 10; done" || echo "Health check timeout"
          
          # Run integration tests
          echo "Running integration tests for web-app"
          curl -f "https://web-app-staging.example.com/health" || exit 1
          curl -f "https://web-app-staging.example.com/" || exit 1
          
          # Load test
          if command -v ab >/dev/null 2>&1; then
            ab -n 100 -c 5 "https://web-app-staging.example.com/"
          fi

  deploy-production:
    needs: [determine-deployment, deploy-staging]
    if: needs.determine-deployment.outputs.should-deploy == 'true' && needs.determine-deployment.outputs.environment == 'production'
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: https://web-app.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_PROD }}
          aws-region: us-east-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region us-east-1 --name prod-cluster

      - name: Backup current deployment
        run: |
          kubectl get deployment ${{ env.SERVICE_NAME }} -n web-app-prod -o yaml > backup-web-app-$(date +%Y%m%d-%H%M%S).yaml || echo "No existing deployment to backup"

      - name: Deploy to production
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.version }}"
          
          # Create production deployment with high availability
          cat << EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: web-app-prod
            labels:
              app: ${{ env.SERVICE_NAME }}
              environment: production
          spec:
            replicas: 3
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxSurge: 1
                maxUnavailable: 0
            selector:
              matchLabels:
                app: ${{ env.SERVICE_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.SERVICE_NAME }}
                  version: ${{ needs.determine-deployment.outputs.version }}
              spec:
                affinity:
                  podAntiAffinity:
                    preferredDuringSchedulingIgnoredDuringExecution:
                    - weight: 100
                      podAffinityTerm:
                        labelSelector:
                          matchExpressions:
                          - key: app
                            operator: In
                            values:
                            - ${{ env.SERVICE_NAME }}
                        topologyKey: kubernetes.io/hostname
                containers:
                - name: ${{ env.SERVICE_NAME }}
                  image: $IMAGE
                  ports:
                  - containerPort: 3000
                  env:
                  - name: NODE_ENV
                    value: "production"
                  - name: PORT
                    value: "3000"
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "200m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 5
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 3
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: web-app-prod
          spec:
            selector:
              app: ${{ env.SERVICE_NAME }}
            ports:
            - port: 80
              targetPort: 3000
            type: ClusterIP
          ---
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: web-app-prod
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/rate-limit: "100"
              nginx.ingress.kubernetes.io/rate-limit-window: "1m"
          spec:
            tls:
            - hosts:
              - web-app.example.com
              secretName: web-app-prod-tls
            rules:
            - host: web-app.example.com
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: ${{ env.SERVICE_NAME }}
                      port:
                        number: 80
          EOF

      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} -n web-app-prod --timeout=900s
          
          # Wait for all pods to be ready
          kubectl wait --for=condition=ready pod -l app=${{ env.SERVICE_NAME }} -n web-app-prod --timeout=300s

      - name: Run production validation
        run: |
          # Wait for ingress to be ready
          timeout 180 bash -c "until curl -f https://web-app.example.com/health 2>/dev/null; do sleep 15; done" || echo "Health check timeout"
          
          # Run production validation tests
          echo "Running production validation for web-app"
          curl -f "https://web-app.example.com/health" || exit 1
          curl -f "https://web-app.example.com/" || exit 1
          
          # Performance validation
          if command -v ab >/dev/null 2>&1; then
            ab -n 50 -c 2 "https://web-app.example.com/"
          fi

      - name: Monitor deployment
        run: |
          echo "Monitoring deployment for 5 minutes..."
          
          for i in {1..10}; do
            READY_PODS=$(kubectl get pods -l app=${{ env.SERVICE_NAME }} -n web-app-prod -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
            TOTAL_PODS=$(kubectl get pods -l app=${{ env.SERVICE_NAME }} -n web-app-prod --no-headers | wc -l)
            
            echo "Ready pods: $READY_PODS/$TOTAL_PODS"
            
            # Test endpoint
            curl -f "https://web-app.example.com/health" || echo "Health check failed"
            
            sleep 30
          done

      - name: Send notification
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
              -H 'Content-type: application/json' \
              --data '{
                "text": "🚀 Web App Production Deployment Successful",
                "attachments": [{
                  "color": "good",
                  "fields": [{
                    "title": "Version",
                    "value": "${{ needs.determine-deployment.outputs.version }}",
                    "short": true
                  }, {
                    "title": "URL",
                    "value": "https://web-app.example.com",
                    "short": true
                  }]
                }]
              }' || echo "Notification failed"
          else
            curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
              -H 'Content-type: application/json' \
              --data '{
                "text": "🚨 Web App Production Deployment Failed",
                "attachments": [{
                  "color": "danger",
                  "fields": [{
                    "title": "Version",
                    "value": "${{ needs.determine-deployment.outputs.version }}",
                    "short": true
                  }]
                }]
              }' || echo "Notification failed"
          fi

  deployment-summary:
    needs: [determine-deployment, deploy-development, deploy-staging, deploy-production]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Deployment Summary
        run: |
          echo "## Web App Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | Version | Status | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|---------|--------|-----|" >> $GITHUB_STEP_SUMMARY
          
          ENVIRONMENT="${{ needs.determine-deployment.outputs.environment }}"
          VERSION="${{ needs.determine-deployment.outputs.version }}"
          
          if [ "$ENVIRONMENT" = "development" ]; then
            STATUS="${{ needs.deploy-development.result }}"
            URL="https://web-app-dev.example.com"
          elif [ "$ENVIRONMENT" = "staging" ]; then
            STATUS="${{ needs.deploy-staging.result }}"
            URL="https://web-app-staging.example.com"
          elif [ "$ENVIRONMENT" = "production" ]; then
            STATUS="${{ needs.deploy-production.result }}"
            URL="https://web-app.example.com"
          fi
          
          echo "| $ENVIRONMENT | $VERSION | $STATUS | $URL |" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** Web App" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY