name: Container Build and Push - API Service

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  packages: write
  id-token: write
  attestations: write

jobs:
  generate-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is-release: ${{ steps.version.outputs.is-release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            IS_RELEASE=true
          elif [[ $GITHUB_REF == refs/heads/main ]]; then
            VERSION=$(date +%Y%m%d)-${GITHUB_SHA::8}
            IS_RELEASE=false
          else
            VERSION=pr-${{ github.event.number }}-${GITHUB_SHA::8}
            IS_RELEASE=false
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is-release=$IS_RELEASE" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

  build-and-push:
    needs: generate-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=${{ needs.generate-version.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=api-service
            org.opencontainers.image.description=Multi-repo API service example
            org.opencontainers.image.vendor=DevOps Team
            org.opencontainers.image.version=${{ needs.generate-version.outputs.version }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=api-service-${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=api-service-${{ matrix.platform }}
          build-args: |
            VERSION=${{ needs.generate-version.outputs.version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v3
        with:
          name: digests
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge-and-sign:
    needs: [generate-version, build-and-push]
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Download digests
        uses: actions/download-artifact@v3
        with:
          name: digests
          path: /tmp/digests

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=${{ needs.generate-version.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Create manifest list and push
        working-directory: /tmp/digests
        id: build
        run: |
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:%s ' *)
          
          # Get the digest of the manifest list
          DIGEST=$(docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.version }} --format '{{.Manifest.Digest}}')
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.version }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.1.1
        with:
          cosign-release: 'v2.2.0'

      - name: Sign container image
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
          DIGEST: ${{ steps.build.outputs.digest }}
        run: |
          images=""
          for tag in ${TAGS}; do
            images+="${tag}@${DIGEST} "
          done
          cosign sign --yes ${images}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.version }}
          format: spdx-json
          output-file: sbom-api-service.spdx.json

      - name: Attest SBOM
        uses: actions/attest-sbom@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.build.outputs.digest }}
          sbom-path: sbom-api-service.spdx.json
          push-to-registry: true

      - name: Upload SBOM
        uses: actions/upload-artifact@v3
        with:
          name: sbom-api-service
          path: sbom-api-service.spdx.json
          retention-days: 30

  vulnerability-scan:
    needs: [generate-version, merge-and-sign]
    runs-on: ubuntu-latest
    
    steps:
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.version }}'
          format: 'sarif'
          output: 'trivy-api-service.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-api-service.sarif'

      - name: Check for critical vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.version }}'
          format: 'json'
          output: 'trivy-api-service.json'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

  api-integration-test:
    needs: [generate-version, merge-and-sign]
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run API integration tests
        run: |
          # Pull and run the built image
          docker run -d --name api-service-test -p 8080:8080 \
            -e DATABASE_URL=postgresql://postgres:postgres@host.docker.internal:5432/testdb \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.version }}
          
          # Wait for API to be ready
          timeout 60 bash -c 'until curl -f http://localhost:8080/health; do sleep 2; done'
          
          # Run API tests
          echo "Running API integration tests..."
          
          # Test health endpoint
          curl -f http://localhost:8080/health || exit 1
          
          # Test API endpoints
          curl -f http://localhost:8080/api/status || exit 1
          
          # Test with load
          for i in {1..20}; do
            curl -s http://localhost:8080/api/status > /dev/null &
          done
          wait
          
          echo "All API tests passed!"
          
          # Cleanup
          docker stop api-service-test
          docker rm api-service-test

  performance-benchmark:
    needs: [generate-version, merge-and-sign]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install performance testing tools
        run: |
          sudo apt-get update
          sudo apt-get install -y apache2-utils

      - name: Run performance benchmarks
        run: |
          # Start API service
          docker run -d --name api-service-perf -p 8080:8080 \
            -e DATABASE_URL=postgresql://postgres:postgres@host.docker.internal:5432/testdb \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.version }}
          
          # Wait for API to be ready
          timeout 60 bash -c 'until curl -f http://localhost:8080/health; do sleep 2; done'
          
          # Run performance tests
          echo "Running performance benchmarks..."
          
          # Baseline test
          ab -n 1000 -c 10 -g baseline.dat http://localhost:8080/api/status
          
          # Stress test
          ab -n 5000 -c 50 -g stress.dat http://localhost:8080/api/status
          
          # Cleanup
          docker stop api-service-perf
          docker rm api-service-perf

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: |
            baseline.dat
            stress.dat
          retention-days: 30

  update-gitops:
    needs: [generate-version, vulnerability-scan]
    if: github.ref == 'refs/heads/main' && needs.generate-version.outputs.is-release == 'false'
    runs-on: ubuntu-latest
    
    steps:
      - name: Trigger GitOps update
        run: |
          echo "Triggering GitOps update for api-service:${{ needs.generate-version.outputs.version }}"
          
          # This would typically trigger an update to your GitOps repository
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/dispatches \
            -d '{
              "event_type": "update-deployment",
              "client_payload": {
                "service": "api-service",
                "version": "${{ needs.generate-version.outputs.version }}",
                "image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.version }}"
              }
            }'

  build-summary:
    needs: [generate-version, build-and-push, merge-and-sign, vulnerability-scan, api-integration-test]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Build Summary
        run: |
          echo "## Container Build Summary - API Service" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Version | Status | Platforms |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|--------|-----------|" >> $GITHUB_STEP_SUMMARY
          echo "| api-service | ${{ needs.generate-version.outputs.version }} | ${{ needs.merge-and-sign.result }} | linux/amd64, linux/arm64 |" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Registry:** ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Signed:** âœ… Image signed with Cosign" >> $GITHUB_STEP_SUMMARY
          echo "**SBOM:** âœ… Software Bill of Materials generated" >> $GITHUB_STEP_SUMMARY
          echo "**Security Scan:** ${{ needs.vulnerability-scan.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Integration Tests:** ${{ needs.api-integration-test.result }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.generate-version.outputs.is-release }}" == "true" ]]; then
            echo "**Release:** ðŸŽ‰ Production release" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Build Type:** ðŸ”§ Development build" >> $GITHUB_STEP_SUMMARY
          fi